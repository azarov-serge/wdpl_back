# Auth — авторизация и аутентификация

Фича регистрации, входа, выхода и обновления токенов. JWT access + refresh-токены в БД.

## Что есть в папке

| Файл | Назначение |
|------|------------|
| `domain.go` | Доменные модели: `User`, `RefreshToken`. |
| `dto.go` | DTO запросов/ответов: `SignUpRequest`, `SignInRequest`, `AuthResponse`. |
| `repository.go` | Интерфейсы: `UserRepository`, `RefreshTokenRepository`. |
| `repository_postgres.go` | Реализация репозиториев для Postgres (таблицы `auth.users`, `auth.refresh_tokens`). |
| `service.go` | Бизнес-логика: регистрация, логин, refresh, отзыв токена, выдача пары access/refresh. |
| `handler.go` | HTTP-хендлеры: парсинг тела, валидация, вызов сервиса, маппинг ошибок в коды. |
| `router.go` | Регистрация маршрутов на группе `/api/auth`. |
| `handler_test.go`, `service_test.go` | Тесты хендлера и сервиса. |

Цепочка: **Router → Handler → Service → Repository**. Зависимости через интерфейсы (DIP).

---

## Роуты

Базовый путь: **`/api/auth`**.

| Метод | Путь | Описание |
|-------|------|----------|
| POST | `/api/auth/sign-up` | Регистрация нового пользователя. |
| POST | `/api/auth/sign-in` | Вход по email и паролю. |
| POST | `/api/auth/sign-out` | Выход: отзыв refresh-токена. |
| POST | `/api/auth/refresh` | Обновление пары токенов по refresh-токену. |

Все эндпоинты без проверки JWT (публичные). Защищённые роуты используют middleware с проверкой access-токена в других фичах.

---

## Алгоритм работы эндпоинтов

### POST `/api/auth/sign-up`

- **Тело:** `{ "email": "...", "password": "..." }` (email — валидный, password — не короче 8 символов).
- **Алгоритм:**
  1. Парсинг и валидация тела.
  2. Проверка, что пользователя с таким email ещё нет (`GetUserByEmail`).
  3. Хеширование пароля (bcrypt).
  4. Создание пользователя в БД (`CreateUser`: id, email, hash, role=`user`, is_active=true).
  5. Выдача пары access + refresh (`issueTokens`), сохранение refresh в БД.
  6. Ответ 200: `userID`, `email`, `role`, `accessToken`, `refreshToken`.
- **Ошибки:** 400 — email уже занят или валидация; 500 — внутренняя ошибка.

---

### POST `/api/auth/sign-in`

- **Тело:** `{ "email": "...", "password": "..." }`.
- **Алгоритм:**
  1. Парсинг и валидация тела.
  2. Поиск пользователя по email (`GetUserByEmail`).
  3. Проверка пароля (bcrypt). Если пользователь не найден или пароль неверный — 401.
  4. Проверка `is_active`; если не активен — 403.
  5. Выдача пары access + refresh, сохранение refresh в БД (с учётом User-Agent и IP из запроса).
  6. Ответ 200: те же поля, что и у sign-up.
- **Ошибки:** 401 — неверный email/пароль; 403 — пользователь неактивен; 500 — внутренняя ошибка.

---

### POST `/api/auth/refresh`

- **Тело:** `{ "refreshToken": "..." }`.
- **Алгоритм:**
  1. Парсинг и валидация тела.
  2. Поиск записи refresh-токена в БД по строке токена.
  3. Проверка: токен существует, не отозван (`revoked_at IS NULL`), не истёк (`expires_at`).
  4. Выдача новой пары access + refresh (старый refresh остаётся валидным до истечения).
  5. Ответ 200: `{ "accessToken": "...", "refreshToken": "..." }`.
- **Ошибки:** 401 — токен невалиден/отозван/истёк; 500 — внутренняя ошибка.  
  Фронт может использовать успешный 200 как проверку «пользователь авторизован».

---

### POST `/api/auth/sign-out`

- **Тело:** `{ "refreshToken": "..." }`.
- **Алгоритм:**
  1. Парсинг и валидация тела.
  2. Поиск записи refresh-токена в БД по строке.
  3. Установка `revoked_at = now()` для этой записи (если найдена). Если не найдена — ничего не делаем (идемпотентность).
  4. Ответ 204 No Content.
- **Ошибки:** 500 — только при сбое БД.

---

## Общее по токенам

- **Access** — JWT, короткий TTL (из конфига `ACCESS_TOKEN_TTL`), подпись `JWT_SECRET`. Используется в заголовке `Authorization: Bearer <token>` на защищённых роутах.
- **Refresh** — случайная строка (UUID), хранится в БД, TTL из `REFRESH_TOKEN_TTL`. Передаётся в теле запросов refresh/sign-out; по нему выдаётся новая пара токенов или выполняется отзыв.
